#version 460

#extension GL_EXT_mesh_shader            : require
#extension GL_KHR_shader_subgroup_ballot : require

const uint TASK_GROUP_SIZE = 32;

layout(local_size_x = TASK_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

struct ModelData
{
    mat4  modelMatrix;
    vec4  modelOffset; // materialIndex on the last component.
    uint  meshIndex;
    float modelScale;
    uint  padding[2];
};

struct Frustum
{
	vec4 left;
	vec4 right;
	vec4 bottom;
	vec4 top;
	vec4 near;
	vec4 far;
};

struct Meshlet
{
	uint vertexCount;
    uint vertexOffset;
    uint primitiveCount;
    uint primitiveOffset;
};

struct MeshletDetails
{
	Meshlet meshlet;
	vec4    sphereBV;
};

struct MeshDetails
{
	uint vertexOffset;
	uint vertexIndicesOffset;
	uint primitiveIndicesOffset;
	uint meshletOffset;
};

struct ModelDetails
{
	uint meshletCount;
	uint meshletOffset;
	uint modelIndex;
};

struct Payload
{
    uint meshletIndices[TASK_GROUP_SIZE];
};

taskPayloadSharedEXT Payload s_Payload;

layout(push_constant) uniform ConstantData
{
	ModelDetails modelDetails;
	MeshDetails  meshDetails;
} constantData;

layout(binding = 0) readonly buffer Modeldata
{
	ModelData models[];
} modelData;

layout(binding = 1) readonly buffer MeshletData
{
	MeshletDetails meshletDetails[];
} meshletData;

layout(binding = 5) uniform CameraMatrices
{
	mat4    view;
	mat4    projection;
	Frustum frustum;
} camera;

bool IsMeshletVisible(ModelData modelDataInst, MeshletDetails meshletDetails)
{
    mat4 world = modelDataInst.modelMatrix;

    return true;
}

void main()
{
	uint threadIndex = gl_WorkGroupID.x * TASK_GROUP_SIZE + gl_LocalInvocationIndex;

	bool isMeshletVisible = false;

	ModelDetails modelDetails = constantData.modelDetails;
	MeshDetails meshDetails   = constantData.meshDetails;

	if (threadIndex < modelDetails.meshletCount)
	{
		uint meshletOffset            = meshDetails.meshletOffset + modelDetails.meshletOffset;
		MeshletDetails meshletDetails = meshletData.meshletDetails[meshletOffset + threadIndex];

		ModelData modelDataInst       = modelData.models[modelDetails.modelIndex];

		isMeshletVisible = IsMeshletVisible(modelDataInst, meshletDetails);
	}

	uvec4 validVotes = subgroupBallot(isMeshletVisible);

	if (isMeshletVisible)
	{
		uint currentIndex = subgroupBallotExclusiveBitCount(validVotes);

		s_Payload.meshletIndices[currentIndex] = threadIndex;
	}

	uint validCount  = subgroupBallotBitCount(validVotes);

	// The arguments are taken on the first invocation.
	EmitMeshTasksEXT(validCount, 1, 1);
}
